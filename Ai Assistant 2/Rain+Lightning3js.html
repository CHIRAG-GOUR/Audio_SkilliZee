<div>
<p><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"></p>
</div>
<title></title>
<style type="text/css">html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;     /* removes tiny bottom gap in some browsers */
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><script>
// ────────────────────────────────────────────────
let scene, camera, renderer;
let cloudParticles = [], rain, rainGeo, flash;
const rainCount = 15000;

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    1,
    1000
  );
  camera.position.z = 1;
  camera.rotation.x = 1.16;
  camera.rotation.y = -0.12;
  camera.rotation.z = 0.27;

  const ambient = new THREE.AmbientLight(0x555555);
  scene.add(ambient);

  const directionalLight = new THREE.DirectionalLight(0xffeedd);
  directionalLight.position.set(0, 0, 1);
  scene.add(directionalLight);

  flash = new THREE.PointLight(0x062d89, 30, 500, 1.7);
  flash.position.set(200, 300, 100);
  scene.add(flash);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  scene.fog = new THREE.FogExp2(0x11111f, 0.002);
  renderer.setClearColor(scene.fog.color);
  renderer.setSize(window.innerWidth, window.innerHeight, false); // false → CSS controls size
  document.body.appendChild(renderer.domElement);

  // Rain
  const positions = new Float32Array(rainCount * 3);
  const sizes     = new Float32Array(rainCount);

  for (let i = 0; i < rainCount; i++) {
    const i3 = i * 3;
    positions[i3 + 0] = Math.random() * 400 - 200;
    positions[i3 + 1] = Math.random() * 500 - 250;
    positions[i3 + 2] = Math.random() * 400 - 200;
    sizes[i] = 30;
  }

  rainGeo = new THREE.BufferGeometry();
  rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  rainGeo.setAttribute('size',     new THREE.BufferAttribute(sizes, 1));

  const rainMaterial = new THREE.PointsMaterial({
    color: 0xaaaaaa,
    size: 0.1,
    transparent: true
  });

  rain = new THREE.Points(rainGeo, rainMaterial);
  scene.add(rain);

  // Clouds
  const loader = new THREE.TextureLoader();
  loader.load(
    'https://static.vecteezy.com/system/resources/previews/010/884/548/original/dense-fluffy-puffs-of-white-smoke-and-fog-on-transparent-background-abstract-smoke-clouds-movement-blurred-out-of-focus-smoking-blows-from-machine-dry-ice-fly-fluttering-in-air-effect-texture-png.png',
    (texture) => {
      const cloudGeo = new THREE.PlaneGeometry(500, 500);
      const cloudMaterial = new THREE.MeshLambertMaterial({
        map: texture,
        transparent: true,
        opacity: 0.55
      });

      for (let p = 0; p < 25; p++) {
        const cloud = new THREE.Mesh(cloudGeo, cloudMaterial);
        cloud.position.set(
          Math.random() * 800 - 400,
          500,
          Math.random() * 500 - 450
        );
        cloud.rotation.x = 1.16;
        cloud.rotation.y = -0.12;
        cloud.rotation.z = Math.random() * 360;
        cloudParticles.push(cloud);
        scene.add(cloud);
      }

      animate();
    }
  );

  window.addEventListener('resize', onWindowResize, false);
}

function animate() {
  cloudParticles.forEach(p => {
    p.rotation.z -= 0.002;
  });

  rain.position.y -= 0.222;
  if (rain.position.y < -200) {
    rain.position.y = 200;
  }

  // Lightning
  if (Math.random() > 0.93 || flash.power > 100) {
    if (flash.power < 100) {
      flash.position.set(
        Math.random() * 400 - 200,
        300 + Math.random() * 200,
        100
      );
    }
    flash.power = 30 + Math.random() * 500;
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight, false);
}

init();
// ────────────────────────────────────────────────
</script>
<p>&nbsp;</p>
