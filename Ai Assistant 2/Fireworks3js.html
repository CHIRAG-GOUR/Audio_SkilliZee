<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fireworks • Deep Boom</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      /* background removed → now transparent */
      font-family: monospace;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
    }
    #overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.65);   /* slightly darker overlay so text remains readable */
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1000;
      font-size: 2.3rem;
      text-align: center;
      user-select: none;
    }
    #overlay span {
      margin-top: 1.3rem;
      font-size: 1.1rem;
      color: #ccc;
    }
    .highlight {
      color: #ffaa44;
      font-weight: bold;
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>
<div id="overlay">
  <div>CLICK ANYWHERE TO CELEBRATE</div>
  <span>Fireworks with <span class="highlight">deep explosion boom</span></span>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ── DEEP BASS AUDIO ────────────────────────────────────────
const AudioSys = {
  ctx: null,
  volume: 0.65,
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    const limiter = this.ctx.createDynamicsCompressor();
    limiter.threshold.value = -12;
    limiter.knee.value = 30;
    limiter.ratio.value = 12;
    limiter.connect(this.ctx.destination);
    this.limiter = limiter;
  },
  playDeepExplosion() {
    if (!this.ctx) return;
    const t = this.ctx.currentTime;
    // sub bass drop
    const osc = this.ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(55, t);
    osc.frequency.exponentialRampToValueAtTime(18, t + 2.8);
    const oscGain = this.ctx.createGain();
    oscGain.gain.setValueAtTime(this.volume * 1.6, t);
    oscGain.gain.exponentialRampToValueAtTime(0.001, t + 5.2);
    osc.connect(oscGain).connect(this.limiter);
    osc.start(t);
    osc.stop(t + 5.2);
    // low rumble noise
    const bufferSize = this.ctx.sampleRate * 5.2;
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    const noiseFilter = this.ctx.createBiquadFilter();
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.setValueAtTime(180, t);
    noiseFilter.frequency.exponentialRampToValueAtTime(25, t + 4.2);
    const noiseGain = this.ctx.createGain();
    noiseGain.gain.setValueAtTime(this.volume * 0.9, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 4.8);
    noise.connect(noiseFilter).connect(noiseGain).connect(this.limiter);
    noise.start(t);
    // fast crack/whoosh
    const crack = this.ctx.createOscillator();
    crack.type = 'triangle';
    crack.frequency.setValueAtTime(220, t);
    crack.frequency.exponentialRampToValueAtTime(60, t + 0.12);
    const crackGain = this.ctx.createGain();
    crackGain.gain.setValueAtTime(this.volume * 0.35, t);
    crackGain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    crack.connect(crackGain).connect(this.limiter);
    crack.start(t);
    crack.stop(t + 0.12);
  }
};

// ── PARTICLE SPRITE ────────────────────────────────────────
function createParticleSprite() {
  const size = 32;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(0.4, 'rgba(255,255,255,0.85)');
  grad.addColorStop(0.6, 'rgba(255,255,255,0.4)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, size, size);
  return new THREE.CanvasTexture(canvas);
}
const particleSprite = createParticleSprite();

// ── CONFIG (tuned for medium speed) ────────────────────────
const CONFIG = {
  particleCount: 18000,
  particleSize: 0.95,
  fadeSpeed: 0.0045,
  explosionForce: 3.1,
  hoverDuration: 1.4,
  gravity: 0.0032,
  friction: 0.96,
  rocketSpeed: 1.0,
  rocketSize: 2.4,
  bloomStrength: 1.55,
  bloomRadius: 0.45,
  trailOpacity: 0.38,
  launchIntervalMin: 2500,
  launchIntervalMax: 4000,
  soundEnabled: true
};

// ── THREE SETUP ─────────────────────────────────────────────
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0018);
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 4000);
camera.position.set(0, 0, 140);

const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });  // ← alpha: true for transparency
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Post-processing
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(
  new THREE.Vector2(innerWidth, innerHeight),
  CONFIG.bloomStrength,
  CONFIG.bloomRadius,
  0.0
));

// Background stars
const starsGeo = new THREE.BufferGeometry();
const starsPos = new Float32Array(3000 * 3);
for (let i = 0; i < starsPos.length; i++) starsPos[i] = (Math.random() - 0.5) * 1400;
starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({
  size: 1.4, color: 0xaaaaaa, map: particleSprite,
  transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
})));

// Fade trail layer
const fadeMat = new THREE.MeshBasicMaterial({
  color: 0x000000, transparent: true, opacity: CONFIG.trailOpacity
});
const fadePlane = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), fadeMat);
fadePlane.position.z = camera.position.z - 60;
scene.add(fadePlane);

// ── FIREWORK CLASS (unchanged core logic) ──────────────────
class Firework {
  constructor(startX) {
    this.isDead = false;
    this.phase = 'rocket';
    this.timer = 0;
    const baseHue = Math.random();
    const rand = Math.random();
    this.colors = [];
    if (rand < 0.33) {
      this.colors.push(new THREE.Color().setHSL(baseHue, 1.0, 0.62));
    } else if (rand < 0.66) {
      this.colors.push(new THREE.Color().setHSL(baseHue, 1.0, 0.62));
      this.colors.push(new THREE.Color().setHSL((baseHue + 0.5) % 1, 0.95, 0.52));
    } else {
      this.colors.push(new THREE.Color().setHSL(baseHue, 1.0, 0.62));
      this.colors.push(new THREE.Color().setHSL((baseHue + 0.33) % 1, 1.0, 0.6));
      this.colors.push(new THREE.Color().setHSL((baseHue + 0.66) % 1, 1.0, 0.58));
    }
    this.pos = new THREE.Vector3(startX, -90, (Math.random()-0.5)*60);
    this.vel = new THREE.Vector3(
      (Math.random() - 0.5) * 0.4,
      CONFIG.rocketSpeed * (0.9 + Math.random() * 0.3),
      (Math.random() - 0.5) * 0.4
    );
    this.targetY = 0 + Math.random() * 35;

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(this.pos.toArray(), 3));
    this.rocketMesh = new THREE.Points(geo, new THREE.PointsMaterial({
      size: CONFIG.rocketSize,
      color: this.colors[0],
      map: particleSprite,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    }));
    scene.add(this.rocketMesh);
  }

  update(dt) { /* unchanged */ 
    if (this.phase === 'rocket') {
      this.pos.add(this.vel);
      this.vel.y *= 0.988;
      this.rocketMesh.geometry.attributes.position.setXYZ(0, this.pos.x, this.pos.y, this.pos.z);
      this.rocketMesh.geometry.attributes.position.needsUpdate = true;
      if (this.vel.y < 0.15 || this.pos.y >= this.targetY) this.explode();
    } else {
      this.timer += dt;
      const posArr = this.sparkSystem.geometry.attributes.position.array;
      const colArr = this.sparkSystem.geometry.attributes.color.array;
      let alive = 0;
      const hovering = this.timer < CONFIG.hoverDuration;
      const gravFactor = THREE.MathUtils.smoothstep(this.timer, CONFIG.hoverDuration, CONFIG.hoverDuration + 0.6);
      for (let i = 0; i < this.currentParticleCount; i++) {
        if (this.lifetimes[i] > 0) {
          alive++;
          const i3 = i * 3;
          posArr[i3] += this.velocities[i3];
          posArr[i3+1] += this.velocities[i3+1];
          posArr[i3+2] += this.velocities[i3+2];
          if (hovering) {
            this.velocities[i3] *= CONFIG.friction;
            this.velocities[i3+1] *= CONFIG.friction;
            this.velocities[i3+2] *= CONFIG.friction;
          } else {
            this.velocities[i3+1] -= CONFIG.gravity * gravFactor;
            this.velocities[i3] *= 0.978;
            this.velocities[i3+1] *= 0.978;
            this.velocities[i3+2] *= 0.978;
            this.lifetimes[i] -= CONFIG.fadeSpeed;
          }
          const a = Math.max(0, this.lifetimes[i]);
          colArr[i3] = this.baseColors[i3] * a * 1.55;
          colArr[i3+1] = this.baseColors[i3+1] * a * 1.55;
          colArr[i3+2] = this.baseColors[i3+2] * a * 1.55;
        }
      }
      this.sparkSystem.geometry.attributes.position.needsUpdate = true;
      this.sparkSystem.geometry.attributes.color.needsUpdate = true;
      if (alive === 0) this.cleanup();
    }
  }

  explode() { /* unchanged */ 
    if (CONFIG.soundEnabled) AudioSys.playDeepExplosion();
    scene.remove(this.rocketMesh);
    this.phase = 'explode';
    this.currentParticleCount = CONFIG.particleCount;
    const geo = new THREE.BufferGeometry();
    const positions = new Float32Array(this.currentParticleCount * 3);
    const colors = new Float32Array(this.currentParticleCount * 3);
    this.baseColors = new Float32Array(this.currentParticleCount * 3);
    this.velocities = new Float32Array(this.currentParticleCount * 3);
    this.lifetimes = new Float32Array(this.currentParticleCount);
    const baseSpeed = CONFIG.explosionForce * (0.85 + Math.random() * 0.35);
    for (let i = 0; i < this.currentParticleCount; i++) {
      const i3 = i * 3;
      positions[i3] = this.pos.x;
      positions[i3+1] = this.pos.y;
      positions[i3+2] = this.pos.z;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const speed = baseSpeed * (0.82 + Math.random() * 0.36);
      this.velocities[i3] = speed * Math.sin(phi) * Math.cos(theta);
      this.velocities[i3+1] = speed * Math.sin(phi) * Math.sin(theta);
      this.velocities[i3+2] = speed * Math.cos(phi);
      const c = this.colors[Math.floor(Math.random() * this.colors.length)];
      const brightness = 0.6 + Math.random() * 0.7;
      this.baseColors[i3] = c.r * brightness;
      this.baseColors[i3+1] = c.g * brightness;
      this.baseColors[i3+2] = c.b * brightness;
      colors[i3] = this.baseColors[i3];
      colors[i3+1] = this.baseColors[i3+1];
      colors[i3+2] = this.baseColors[i3+2];
      this.lifetimes[i] = 1.0;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    this.sparkSystem = new THREE.Points(geo, new THREE.PointsMaterial({
      size: CONFIG.particleSize,
      map: particleSprite,
      transparent: true,
      depthWrite: false,
      vertexColors: true,
      blending: THREE.AdditiveBlending
    }));
    scene.add(this.sparkSystem);
  }

  cleanup() { /* unchanged */ 
    this.isDead = true;
    if (this.sparkSystem) {
      scene.remove(this.sparkSystem);
      this.sparkSystem.geometry.dispose();
      this.sparkSystem.material.dispose();
    }
    if (this.rocketMesh) {
      scene.remove(this.rocketMesh);
      this.rocketMesh.geometry.dispose();
      this.rocketMesh.material.dispose();
    }
  }
}

// ── MAIN LOOP ───────────────────────────────────────────────
const fireworks = [];
let lastLaunch = 0;
let nextDelay = 2800;

function launch() {
  const x = (Math.random() - 0.5) * 160;
  fireworks.push(new Firework(x));
}

function tryLaunch(now) {
  if (now - lastLaunch > nextDelay) {
    lastLaunch = now;
    nextDelay = CONFIG.launchIntervalMin + Math.random() * (CONFIG.launchIntervalMax - CONFIG.launchIntervalMin);
    launch();
  }
}

const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const now = performance.now();
  tryLaunch(now);
  for (let i = fireworks.length - 1; i >= 0; i--) {
    fireworks[i].update(dt);
    if (fireworks[i].isDead) fireworks.splice(i, 1);
  }
  composer.render();
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
});

// ── START ───────────────────────────────────────────────────
const overlay = document.getElementById('overlay');
overlay.addEventListener('click', () => {
  AudioSys.init();
  if (AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
  overlay.style.display = 'none';
  launch(); // first one immediately
  animate(); // start loop
}, { once: true });
</script>
</body>
</html>